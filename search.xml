<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[vue脚手架3.0的使用]]></title>
    <url>%2F2018%2F08%2F29%2Fvue%2Fvue-cli3-0%2F</url>
    <content type="text"><![CDATA[Node 版本要求 Vue CLI 需要 Node.js 8.9 或更高版本 (推荐 8.11.0+)。你可以使用 nvm 或 nvm-windows 在同一台电脑中管理多个 Node 版本。 安装新的脚手架包123npm install -g @vue/cli# ORyarn global add @vue/cli 创建一个新的项目 create 1vue create admin 12345Vue CLI v3.0.1? Please pick a preset: init-cli (vue-router, vuex, stylus, babel, eslint) default (babel, eslint)&gt; Manually select features 选择默认还是手动安装，我这里选择的是手动的，可以安装更多的配置项 选择配置 这里可以自由选择用哪些配置，按上下键选择哪一个，按空格键确定，所有的都选择好后，按enter键进行下一步 123456789101112Vue CLI v3.0.1? Please pick a preset: Manually select features? Check the features needed for your project: (*) Babel ( ) TypeScript ( ) Progressive Web App (PWA) Support (*) Router (*) Vuex&gt;(*) CSS Pre-processors (*) Linter / Formatter ( ) Unit Testing ( ) E2E Testing 是否启用history模式 1234Vue CLI v3.0.1? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors, Linter? Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) 选择css预处理，这里我选择stylus 12345678Vue CLI v3.0.1? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors, Linter? Use history mode for router? (Requires proper server setup for index fallback in production) No? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): SCSS/SASS LESS&gt; Stylus 选择ESLint + Prettier 12345678910Vue CLI v3.0.1? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors, Linter? Use history mode for router? (Requires proper server setup for index fallback in production) No? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Stylus? Pick a linter / formatter config: ESLint with error prevention only ESLint + Airbnb config ESLint + Standard config&gt; ESLint + Prettier Prettier的中文意思是“漂亮的、机灵的”，也是一个流行的代码格式化工具的名称，它能够解析代码，使用你自己设定的规则来重新打印出格式规范的代码。 Prettier具有以下几个有优点： 可配置化 支持多种语言 集成多数的编辑器 简洁的配置项 选择css预处理，这里我选择stylus 123456789Vue CLI v3.0.1? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors, Linter? Use history mode for router? (Requires proper server setup for index fallback in production) No? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Stylus? Pick a linter / formatter config: Prettier? Pick additional lint features: (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)&gt;(*) Lint on save // 保存就检测 ( ) Lint and fix on commit // fix和commit时候检查 把babel,postcss,eslint这些配置文件放哪,我选择放在独立文件夹 12345678910Vue CLI v3.0.1? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors, Linter? Use history mode for router? (Requires proper server setup for index fallback in production) No? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Stylus? Pick a linter / formatter config: Prettier? Pick additional lint features: Lint on save? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? (Use arrow keys)&gt; In dedicated config files In package.json 是否保存本次配置，下次create的时候可以直接使用 123456789Vue CLI v3.0.1? Please pick a preset: Manually select features? Check the features needed for your project: Babel, Router, Vuex, CSS Pre-processors, Linter? Use history mode for router? (Requires proper server setup for index fallback in production) No? Pick a CSS pre-processor (PostCSS, Autoprefixer and CSS Modules are supported by default): Stylus? Pick a linter / formatter config: Prettier? Pick additional lint features: Lint on save? Where do you prefer placing config for Babel, PostCSS, ESLint, etc.? In dedicated config files? Save this as a preset for future projects? (y/N) 等待依赖下载完毕 12cd adminnpm run serve 需要在根目录配置vue.config.js 配置参考]]></content>
      <tags>
        <tag>vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VUE开发过程中的总结]]></title>
    <url>%2F2018%2F08%2F29%2Fvue%2Fvue%2F</url>
    <content type="text"><![CDATA[安装的依赖 vue-wechat-title Vuejs 单页应用在iOS系统下部分APP的webview中 标题不能通过 document.title = xxx 的方式修改 该插件只为解决该问题而生(兼容安卓) npm地址]]></content>
      <tags>
        <tag>vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装node版本管理工具-NVM]]></title>
    <url>%2F2018%2F08%2F29%2Fnvm%2F</url>
    <content type="text"><![CDATA[window版本nvm-window下载地址 This is not the same thing as nvm, which is a completely separate project for Mac/Linux only. 查询node官网需要安装的node版本 1nvm install 10.9.0 使用安装的版本 1nvm use 10.9.0 查询已安装的版本 1nvm list]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue自动化部署]]></title>
    <url>%2F2018%2F08%2F28%2Fjenkins%2F</url>
    <content type="text"><![CDATA[部署node环境使用二进制文件安装该部署过程使用的安装包是已编译好的二进制文件，解压之后，在bin文件夹中就已存在node和npm，无需手工编译。 安装步骤： wget命令下载Node.js安装包。该安装包是编译好的文件，解压之后，在bin文件夹中就已存在node和npm，无需重复编译。 1wget https://nodejs.org/dist/v6.9.5/node-v6.9.5-linux-x64.tar.xz 解压文件。 1tar xvf node-v6.9.5-linux-x64.tar.xz 创建软链接，使node和npm命令全局有效。通过创建软链接的方法，使得在任意目录下都可以直接使用node和npm命令： 12ln -s /root/node-v6.9.5-linux-x64/bin/node /usr/local/bin/nodeln -s /root/node-v6.9.5-linux-x64/bin/npm /usr/local/bin/npm 查看node. npm版本。 12node -vnpm -v 至此，Node.js环境已安装完毕。软件默认安装在/root/node-v6.9.5-linux-x64/目录下。如果需要将该软件安装到其他目录（如：/opt/node/）下，请进行如下操作： 123456mkdir -p /opt/node/mv /root/node-v6.9.5-linux-x64/* /opt/node/rm -f /usr/local/bin/noderm -f /usr/local/bin/npmln -s /opt/node/bin/node /usr/local/bin/nodeln -s /opt/node/bin/npm /usr/local/bin/npm 搭建git服务器 安装git服务器端： 1#yum install -y git 安装完后，查看 Git 版本 12[root@localhost ~]# git --versiongit version 1.7.1 服务器端创建 git 用户，用来管理 Git 服务，并为 git 用户设置密码 12345// 查询用户[root@localhost home]# id gitid: git：无此用户[root@localhost home]# useradd git[root@localhost home]# passwd git useradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。 服务器端创建 Git 仓库设置 /home/git-repository/test.git 为 Git 仓库然后把 Git 仓库的 owner 修改为 git 12345[root@localhost home]# mkdir -p git-repository/test.git[root@localhost home]# git init --bare git-repository/test.gitInitialized empty Git repository in /home/git-repository/test.git/[root@localhost home]# cd git-repository/[root@localhost git]# chown -R git:git test.git/ 客户端 clone 远程仓库 1$ git clone ssh://git@192.168.1.101:8088/home/git-repository/test.git/ 当第一次连接到目标 Git 服务器时会得到一个提示： 123The authenticity of host &apos;192.168.56.101 (192.168.56.101)&apos; can&apos;t be established.RSA key fingerprint is SHA256:Ve6WV/SCA059EqoUOzbFoZdfmMh3B259nigfmvdadqQ.Are you sure you want to continue connecting (yes/no)? 选择 yes： 1Warning: Permanently added &apos;192.168.56.101&apos; (RSA) to the list of known hosts. 此时 C:\Users\用户名.ssh 下会多出一个文件 known_hosts，以后在这台电脑上再次连接目标 Git 服务器时不会再提示上面的语句后面提示要输入密码，可以采用 SSH 公钥来进行验证。 客户端创建 SSH 公钥和私钥 1$ ssh-keygen -t rsa -C "*****@qq.com" 此时 C:\Users\用户名.ssh 下会多出两个文件 id_rsa 和 id_rsa.pub id_rsa 是私钥 id_rsa.pub 是公钥 服务器端 Git 打开 RSA 认证进入 /etc/ssh 目录，编辑 sshd_config，打开以下三个配置的注释： 123RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys 保存并重启 sshd 服务： 1[root@localhost ssh]# /etc/rc.d/init.d/sshd restart 由 AuthorizedKeysFile 得知公钥的存放路径是 .ssh/authorized_keys，实际上是 $Home/.ssh/authorized_keys，由于管理 Git 服务的用户是 git，所以实际存放公钥的路径是 /home/git/.ssh/authorized_keys 在 /home/git/ 下创建目录 .ssh 12345[root@localhost git]# pwd/home/git[root@localhost git]# mkdir .ssh[root@localhost git]# ls -a . .. .bash_logout .bash_profile .bashrc .gnome2 .mozilla .ssh 然后把 .ssh 文件夹的 owner 修改为 git 123456789101112[root@localhost git]# chown -R git:git .ssh[root@localhost git]# ll -a总用量 32drwx------. 5 git git 4096 8月 28 20:04 .drwxr-xr-x. 8 root root 4096 8月 28 19:32 ..-rw-r--r--. 1 git git 18 10月 16 2014 .bash_logout-rw-r--r--. 1 git git 176 10月 16 2014 .bash_profile-rw-r--r--. 1 git git 124 10月 16 2014 .bashrcdrwxr-xr-x. 2 git git 4096 11月 12 2010 .gnome2drwxr-xr-x. 4 git git 4096 5月 8 12:22 .mozilladrwxr-xr-x. 2 git git 4096 8月 28 20:08 .ssh 将客户端公钥导入服务器端 /home/git/.ssh/authorized_keys 文件回到 Git Bash 下，导入文件： 1$ ssh git@192.168.56.101 'cat &gt;&gt; .ssh/authorized_keys' &lt; ~/.ssh/id_rsa.pub 需要输入服务器端 git 用户的密码 回到服务器端，查看 .ssh 下是否存在 authorized_keys 文件： 1234[root@localhost git]# cd .ssh[root@localhost .ssh]# ll总用量 4-rw-rw-r--. 1 git git 398 8月 28 20:08 authorized_keys 可以查看一下是否是客户端生成的公钥。 重要： 修改 .ssh 目录的权限为 700 修改 .ssh/authorized_keys 文件的权限为 600 123[root@localhost git]# chmod 700 .ssh[root@localhost git]# cd .ssh[root@localhost .ssh]# chmod 600 authorized_keys Jenkins使用git 仓库为ssh地址需要加入秘钥 给Jenkins使用root权限执行脚本 将jenkins账号分别加入到root组中 1gpasswd -a root jenkins 修改/etc/sysconfig/jenkins文件中， 12JENKINS_USER=rootJENKINS_GROUP=root 可以修改为root权限运行 重启Jenkins 1service Jenkins restart 验证在Jenkins中的shell脚本中执行命令 1whoami jenkins执行shell脚本（npm: command not found） 安装 node plugin 配置服务器环境变量123// vim /etc/profileexport NODE_HOME=/root/node-v6.9.5-linux-x64export PATH=$NODE_HOME/bin:$PATH shell脚本123456#!/bin/bashecho "安装！"npm installsleep 1echo "编译！"npm run build || &#123; echo "编译失败！"; exit 1; &#125;]]></content>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建全局事件（global event bus ）]]></title>
    <url>%2F2018%2F06%2F22%2Fevent-bus%2F</url>
    <content type="text"><![CDATA[在使用美团的开源框架mpvue开发小程序，遇到一个页面直接相互调用方法的问题，以前小程序原生写法是通过getCurrentPage()来获取页面Page对象来使用已经定义的方法，在用mpvue后，发现无法使用getCurrentPage()来获取了，决定另辟蹊径。第一个想法是用vuex来管理所有想要变动的数据，尝试后发现得重复的写各种方法和数据，不太适用小程序。在看vuex的官网看到了这么一段话: 如果您不打算开发大型单页应用，使用 Vuex 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 Vuex。一个简单的 global event bus 就足够您所需了。(https://vuex.vuejs.org/zh/) 接下来就具体看看怎么使用 global event bus 吧 创建事件总线12import Vue from 'vue'export default new Vue() 首页我们创建一个event-bus.js,里面export一个vue实例 发送事件12345678import EventBus from '@/utils/event-bus'export default &#123; methods: &#123; tab(index) &#123; EventBus.$emit('change', index) &#125; &#125;&#125; 接受事件12345678import EventBus from '@/utils/event-bus'export default &#123; mounted() &#123; EventBus.$on('change', function(index) &#123; console.log(index) &#125;) &#125;&#125; 接受事件123456import EventBus from '@/utils/event-bus'export default &#123; beforeDestroy() &#123; EventBus.$off('change'); &#125;&#125; global event bus 可以在兄弟组件之间通信]]></content>
      <tags>
        <tag>mpvue</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法--数组篇]]></title>
    <url>%2F2018%2F05%2F20%2Falgorithm-array%2F</url>
    <content type="text"><![CDATA[前端开发在平时工作中需要算法的比较少，但是学习数据结构与算法对分析问题是有帮助的，提供一些快速解决问题的思路。这里先总结一些比较经典的算法，做个笔记，会持续更新…… 数组去重12345678910function removeDuplicates(nums) &#123; for (var i = 0; i &lt; nums.length; i++) &#123; var index = nums.indexOf(nums[i], i + 1); if (index &gt; -1) &#123; nums.splice(index, 1) i--; // 上一步使数组长度缩短了 &#125; &#125; return nums&#125; 数组打乱1234567891011121314function getRandomInt(min, max) &#123; return Math.floor(Math.random() * (max - min + 1) + min);&#125;function shuffle(arr) &#123; var _arr = arr.slice(); for (var i = 0; i &lt; _arr.length; i++) &#123; var r = getRandomInt(0, i); var t = _arr[i]; _arr[i] = _arr[r]; _arr[r] = t; &#125; return _arr;&#125; 冒泡排序123456789101112function bubbleSort(nums) &#123; for (var i = 0; i &lt; nums.length - 1; i++) &#123; for (var j = 0; j &lt; nums.length - 1 - i; j++) &#123; if (nums[j] &gt; nums[j + 1]) &#123; var t = nums[j] nums[j] = nums[j + 1] nums[j + 1] = t &#125; &#125; &#125; return nums&#125; 快速排序1234567891011121314151617function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr &#125; var pivotIndex = Math.floor(arr.length / 2) var pivot = arr.splice(pivotIndex, 1)[0] var left = [] var right = [] for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125; else &#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot], quickSort(right)); &#125; 选择排序1234567891011121314function selectionSort(arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; var minIndex = i; for (var j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[minIndex]) &#123; minIndex = j; &#125; &#125; var temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; &#125; return arr;&#125; 买卖股票112345678910// 假设有一个数组，它的第i个元素是一支给定的股票在第i天的价格。如果你最多只允许完成一次交易(例如,一次买卖股票),设计一个算法来找出最大利润。function maxProfit1() &#123; let low = prices[0]; let max = 0; for (let i = 1; i &lt; prices.length; i++) &#123; max = Math.max(max, prices[i] - low); low = Math.min(prices[i], low) &#125; console.log(max) &#125; 买卖股票21234567891011121314151617 // 假设有一个数组，它的第i个元素是一个给定的股票在第i天的价格。设计一个算法来找到最大的利润。你可以完成尽可能多的交易(多次买卖股票)。然而,你不能同时参与多个交易(你必须在再次购买前出售股票)。function maxProfit2() &#123; let begin = prices[0]; let end = prices[0]; let sum = 0; for (let i = 0; i &lt; prices.length; i++) &#123; if (prices[i] &gt; end) &#123; end = prices[i]; &#125; else &#123; sum = sum + end - begin begin = prices[i]; end = prices[i]; &#125; &#125; sum = sum + end - begin console.log(sum)&#125;]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
